/* 
Header Section:

Declares the yyerror and yylex functions.
Includes necessary standard libraries.
Declares global variables and function prototypes for symbol table management.

Yacc Definitions:

Defines a union for different types that the lexical analyzer can return.
Specifies the starting rule and tokens with their associated types.
Specifies the types for non-terminals.
Grammar Rules and Actions:

Defines the grammar rules and their corresponding actions in C.
Handles assignment, print, and exit commands.
Allows recursive rules to handle multiple statements.

C Code Section:

Implements functions for symbol table management.
Initializes the symbol table in the main function.
Defines the yyerror function for error handling.  */



%{
void yyerror (char *s);
int yylex(void);                        
#include <stdio.h>              /* C declarations used in actions */ 
#include <stdlib.h> 
#include <ctype.h>              /* Include ctype.h for islower and isupper */

int symbols[52];           /* a-zA-Z */ 
int symbolVal(char symbol);   /* give a symbol: look on the table the respective value */ 
void updateSymbolVal(char symbol, int val);
%}

 /* Yacc definitions */
%union {int num; char id;}             /* specify different types that lexical analyzer can return */ 
%start line
%token print 
%token exit_command
%token <num> number 
%token <id> identifier 
%type <num> line exp term 
%type <id> assignment 

%%

/* second section: description of expected inputs     corresponding actions (int C) */

line                   :  assignment  ';'                    {;}     /* nothing */ 
                         |  exit_command  ';'               {exit(EXIT_SUCCESS);}      /* exit, printf are build in functions in C */
                         |  print exp ';'                          {printf("Printing %d\n", $2);}
                         |  line assignment  ';'             {;}
                         |  line print exp   ';'                 {printf("Printing %d\n", $3);} /* recersive, let us repetitively add statements to our program */ 
                         |  line exit_command  ';'         {exit(EXIT_SUCCESS);}
                         ;

assignment   :   identifier   '='    exp  {  updateSymbolVal($1,$3);  }
                        ;
exp                   :   term                        {$$ = $1;}
                         |   exp  '+'  term           {$$ = $1  + $3;}
                         |   exp  '-'   term           {$$ = $1  -  $3;}
                         ;
term                  :   number                   {$$  =  $1;}
                         |   identifier                  {$$ = symbolVal($1);}
                         ;
%%

                      /* C code */

int computeSymbolIndex(char token)
{
  int idx = -1;
  if(islower(token)) {
    idx = token - 'a' + 26;   /* 26 - 51 */
  } else if(isupper(token)) {
    idx = token - 'A';   /* 0 - 25 */ 
  }
  return idx; 
}

/* returns the value of a given sybol */
int symbolVal(char symbol)
{
  int bucket = computeSymbolIndex(symbol);
  return symbols[bucket];
}

/* updates the value of a given symbol */
void updateSymbolVal(char symbol, int val)
{
  int bucket = computeSymbolIndex(symbol);
  symbols[bucket] = val;
}

int main (void) {
  /* init symbol table */
  int i;
  for(i=0; i<52; i++) {
    symbols[i] = 0;
  }

  return yyparse ( );  /* function generated by yacc, apply the grammar rules to the input until it either runs out of input or it actually finds a syntax error */ 
}

void yyerror (char *s) {fprintf (stderr, "%s\n", s);}



                        